---
title: "MEA Analysis James Crowe"
author: "David Colameo"
date: "2024-10-28"
output: html_document
editor_options: 
  chunk_output_type: console
---

## Load Libraries and useful functions


```{r message=FALSE, warning=FALSE}

library(dplyr)
library(stringr)
library(ggplot2)
library(lmerTest)
library(emmeans)


##agregation function
ag <- function(df, cols, fun=mean) {
  c <- colnames(df[,unlist(lapply(df, is.numeric))])
  print(c)
  df <- aggregate(df[,c], by=as.list(df[,cols]), FUN=fun)
  return(df[, colSums(is.na(df)) != nrow(df)])
}
```




## Load Data and clean-up Burst Analysis Data


Change path to folder with excel files generated by the python script. They can be inside subfolders as the function searches them recursively.

- This chunk of code extracts information from the path of the recordings. Make sure, the organisation is the same or change organisation accordingly.
- You can find the description on how to do it below:

- To facilitate the workflow later on with other tables, I created a function which can be applied to any table containing this structure of information within the path

### The function repeated over the whole workflow

Read comments to understand on how to adapt to new paths

```{r}

clean_table_mea <- function(df.ag){
split_path <- function(x) if (dirname(x)==x) x else c(basename(x),split_path(dirname(x)))

##Extract the filename from path

## the index inside square brackets decides which part of the path will be 
## extracted. 
## Here the [1] is the file name, [2] would be set ect.
## "C:\\Users\\James\\Desktop\\Jupyter\\SET1\\2023-11-24T14-53-19_E15_SP_WT3_PTX_N+A.h5"
df.ag$FileName <- sapply(df.ag$File, function(x){
  split_path(x)[1]
})


## this chunk extracts the set name from the path, see above
df.ag$Set <- sapply(df.ag$column_label, function(x){
  split_path(x)[2]
  
})

## Add more columns by copy pasting the chunk above and adapting the square bracket index
## to the element of path you want to extract


#################################################################################
### Extract information from the original recording filename
#################################################################################

## this chunk of code splits the file name by the character "_" and takes the 
## first element which in this case is the date of recording

df.ag$Date <- sapply(df.ag$FileName, function(x){
  unlist(str_split(x, "_"))[1]
})

## Same with E13-15
df.ag$E.No <- sapply(df.ag$FileName, function(x){
  unlist(str_split(x, "_"))[2]
})

df.ag$Genotype <- sapply(df.ag$FileName, function(x){
  unlist(str_split(x, "_"))[3]
})

df.ag$Brainregion <- sapply(df.ag$FileName, function(x){
  unlist(str_split(x, "_"))[4]
})

#############
### Add more chunks from above if you want to extract more information from path
#############


### Condition needed to have "N+A" added 
df.ag$Condition <- sapply(df.ag$FileName, function(x){
  unlist(str_split(x, "_"))[5]
})

df.ag$Condition <- ifelse(df.ag$Condition == "PTX", "PTX_N+A", df.ag$Condition)
df.ag$Condition <- sapply(df.ag$Condition, function(x){
  unlist(str_split(x, "\\."))[1]
})


############# 
#### in some instances, genotype and brainregion was mixed up, so I corrected it here
#############
unique(df.ag$Genotype)

df.ag$Genotype2 <- sapply(df.ag$FileName, function(x){
  unlist(str_split(x, "_"))[4]
})

df.ag$Genotype <- ifelse(df.ag$Genotype %in% c("WT3", "KO",  "GD1", "I9"), df.ag$Genotype, df.ag$Genotype2)
df.ag$Brainregion <- ifelse(grepl("SP", df.ag$FileName), "SP", NA)
df.ag$Brainregion <- ifelse(grepl("CTX", df.ag$FileName), "CTX", df.ag$Brainregion)
df.ag$Genotype <- ifelse(grepl("WT", df.ag$Genotype), "WT", df.ag$Genotype)

## Create a unique experimental ID from Set and genotype
df.ag$Exp_ID <- paste(df.ag$Set, df.ag$Genotype, df.ag$Brainregion, sep=".")
df.ag
}
```


```{r}
##change path here
wd_path <- "C:\\Users\\davec\\Documents\\R-Markdowns\\MEA_James\\MEA"

l_files <- list.files(path = wd_path ,pattern = "*.xlsx$", recursive = TRUE, full.names = TRUE)
l_files <- l_files[!grepl("SET", l_files) & !grepl("Jupyter", l_files) & !grepl("~", l_files)]

dfs <- lapply(l_files, function(x){
  as.data.frame(readxl::read_xlsx(x, sheet="Burst Level Analysis"))
})

names(dfs) <- l_files

df <- bind_rows(dfs, .id = "column_label")

#df <- df[df$Burst_Peak_frequency > 1,]

df.ag <- ag(df, cols= c("column_label", "File"))

df.burst <- clean_table_mea(df.ag)
df.burst.single <- clean_table_mea(df)

```

## Plot Burst Results and Statistics

You can plot whichever numeric parameter from the burst table by changing the column you want to have displayed

- here I plotted the Burst_peak_frequency which shows how many units are participating in a burst
- isi_s is another interesting metric which is related to the frequency of burst over the whole recording

Since the recordings have a rather high variabilty, I plotted them as log-transformed values


Statistics: I opted for a linear mixed model (lmer), which is similar to a two-way anova. The difference is, that the model takes into account
the repeated measurements (baseline, PTX and PTX+NA). Furthermore, it has far fewer assumptions as an ANOVA.

For contrasting different conditions, I suggest to take a Dunn's test, where the conditions are compared to a control condition. You could also do a pairwise testing but you would lose power as most contrasts are not of interest.

I separated WT and KO from I9 and GD9. Here, you have decide which statistical design makes most sense, as I dont have the full biological background to judge for it.

```{r}
ggplot(df.burst, aes(x=Genotype, y=log10(Burst_Peak_frequency), color=Set, fill=Condition, group=interaction(Genotype, Condition))) + geom_boxplot(alpha=0.4) + geom_point(position=position_jitterdodge(0)) + facet_grid(.~Brainregion, scales="free")


df.burst$Genotype <- factor(df.burst$Genotype, levels= c("WT", "KO", "I9", "GD1"))

mod <- lmer(log10(Burst_Peak_frequency) ~ Genotype * Condition * Brainregion + (1|Exp_ID), subset(df.burst, Genotype %in% c("WT", "KO")))
summary(mod)
emmeans(mod, trt.vs.ctrl ~ Condition | Genotype | Brainregion, ref="BASE")
emmeans(mod, trt.vs.ctrl ~ Genotype | Condition | Brainregion, ref="WT")

mod <- lmer(log10(Burst_Peak_frequency) ~ Genotype * Condition * Brainregion + (1|Exp_ID), subset(df.burst, Genotype %in% c("I9", "GD1")))
summary(mod)
emmeans(mod, trt.vs.ctrl ~ Condition | Genotype | Brainregion, ref="BASE")
emmeans(mod, trt.vs.ctrl ~ Genotype | Condition | Brainregion, ref="I9")
```

## Interspike Interval in seconds

see above

```{r}
ggplot(df.burst, aes(x=Genotype, y=log10(isi_s), color=Set, fill=Condition, group=interaction(Genotype, Condition))) + geom_boxplot(alpha=0.4) + geom_point(position=position_jitterdodge(0)) + facet_grid(.~Brainregion, scales="free")

mod <- lmer(log10(isi_s) ~ Genotype * Condition * Brainregion + (1|Exp_ID), subset(df.burst, Genotype %in% c("WT", "KO")))
summary(mod)
emmeans(mod, trt.vs.ctrl ~ Condition | Genotype | Brainregion, ref="BASE")
emmeans(mod, trt.vs.ctrl ~ Genotype | Condition | Brainregion, ref="WT")

mod <- lmer(log10(isi_s) ~ Genotype * Condition * Brainregion + (1|Exp_ID), subset(df.burst, Genotype %in% c("I9", "GD1")))
summary(mod)
emmeans(mod, trt.vs.ctrl ~ Condition | Genotype | Brainregion, ref="BASE")
emmeans(mod, trt.vs.ctrl ~ Genotype | Condition | Brainregion, ref="I9")
```


## Normalize to Baseline Measurement

I dont recommend this approach but if you want to normalize the PTX and PTX+NA condition to baseline, run this chunk of code.

One condition (baseline) will be dropped.

```{r}

col <- c("Set", "Genotype", "Brainregion")
df.merged <- merge(subset(df.burst, Condition == "BASE"), subset(df.burst, Condition != "BASE"), by=col, suffixes = c(".base", ".act"))


df.merged$NormBurstFrq <- df.merged$Burst_Peak_frequency.act / df.merged$Burst_Peak_frequency.base
df.merged$NormISI_s <- df.merged$isi_s.act / df.merged$isi_s.base


ggplot(df.merged, aes(x=Genotype, y=log10(NormISI_s), color=Set, fill=Condition.act, group=interaction(Genotype, Condition.act))) + geom_boxplot(alpha=0.4) + geom_point(position=position_jitterdodge(0)) + facet_grid(.~Brainregion, scales="free")



mod <- lmer(log10(NormISI_s) ~ Genotype * Condition.act * Brainregion + (1|Set), subset(df.merged, Genotype %in% c("I9", "GD1")))
summary(mod)
emmeans(mod, pairwise ~ Condition.act | Genotype | Brainregion)
emmeans(mod, pairwise ~ Genotype | Condition.act | Brainregion)


mod <- lmer(log10(NormISI_s) ~ Genotype * Condition.act * Brainregion + (1|Set), subset(df.merged, Genotype %in% c("WT", "KO")))
summary(mod)
emmeans(mod, pairwise ~ Condition.act | Genotype | Brainregion)
emmeans(mod, pairwise ~ Genotype | Condition.act | Brainregion)


mod <- lmer(log10(NormBurstFrq) ~ Genotype * Condition.act * Brainregion + (1|Set), subset(df.merged))
summary(mod)
emmeans(mod, pairwise ~ Condition.act | Genotype | Brainregion)
emmeans(mod, pairwise ~ Genotype | Condition.act | Brainregion)


mod <- lmer(log10(NormBurstFrq) ~ Genotype * Condition.act * Brainregion + (1|Set), subset(df.merged))
summary(mod)
emmeans(mod, pairwise ~ Condition.act | Genotype | Brainregion)
emmeans(mod, pairwise ~ Genotype | Condition.act | Brainregion)


```



## Load and Clean up of Activity Level Analysis

Similar workflow as with burst level analysis, we can also look at individual spike (aka peaks) information such as amplitude and frequency.

Just be aware that frequency here is calculated per electrode and there is no information about other electrodes like with bursts.

The information extraction takes a while since we have so many peaks:
  - comment out the last line if you want to save some time

```{r}

wd_path <- "C:\\Users\\davec\\Documents\\R-Markdowns\\MEA_James\\MEA"

l_files <- list.files(path = wd_path ,pattern = "*.xlsx$", recursive = TRUE, full.names = TRUE)

l_files <- l_files[!grepl("SET", l_files) & !grepl("Jupyter", l_files) & !grepl("~", l_files)]

dfs <- lapply(l_files, function(x){
  as.data.frame(readxl::read_xlsx(x, sheet="Peak Level Analysis"))
})

names(dfs) <- l_files

df <- bind_rows(dfs, .id = "column_label")

#df <- df[df$Burst_Peak_frequency > 1,]

df.ag <- ag(df, cols= c("column_label", "File", "channel"))


## Add information about recordings
df.ag.peak <- clean_table_mea(df.ag)
df.peak <- clean_table_mea(df)

```


## Plot a recording

subselect recordings otherwise ggplot will be overwhelmed

Here, I am plotting the baseline, PTX and PTX+NA of a particular recording side by side


I included also the information about the detected bursts frmo the previous analysis

Restricted to the first 60 sec. can extended but readibility will suffer.

I also included a filter for Burst_Peak_Frequency of 1hz.

```{r}

id <- "RS1.WT.CTX"

stop_time <- 60
ggplot(subset(df.peak, Exp_ID == id & peak_time_s < stop_time), aes(x=peak_time_s, y=channel, color=channel)) + geom_vline(data=subset(df.burst.single, Exp_ID == id & Burst_Peak_frequency > 1 & 200*burst_time_s < stop_time), mapping=aes(xintercept =200* burst_time_s), alpha=0.5) + geom_point() +
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank() 
        )  + guides(color = FALSE) + facet_grid(~Condition) 


```



## Filter Channels without activity


Filter silent or noisy electrodes here.

```{r}

df.sum <- ag(df.peak, cols= c("column_label", "File", "channel"), fun=sum)


cols<- c("column_label", "File", "channel", "event")
df.ag.peak <- merge(df.ag.peak, df.sum[,cols], by=c("column_label", "File", "channel"))


## set threshold here, you can also add more filters
threshold <- 5
df.ag.peak <- df.ag.peak[df.ag.peak$event.y > threshold,]


df.ag.peak <- ag(df.ag.peak, cols= c("column_label", "File"))

df.ag.peak <- clean_table_mea(df.ag.peak)

```


## Plotting and statistics

Like above with burst level analysis

```{r}
ggplot(df.ag.peak, aes(x=Genotype, y=Amplitude_mV, color=Set, fill=Condition, group=interaction(Genotype, Condition))) + geom_boxplot(alpha=0.4) + geom_point(position=position_jitterdodge(0)) + facet_grid(.~Brainregion, scales="free")

ggplot(df.ag.peak, aes(x=Genotype, y=isi_s, color=Exp_ID, fill=Condition, group=interaction(Genotype, Condition))) + geom_boxplot(alpha=0.4) + geom_point(position=position_jitterdodge(0)) + facet_grid(.~Brainregion, scales="free") + guides(color=FALSE)

df.ag.peak$Genotype <- factor(df.ag.peak$Genotype, levels= c("WT", "KO", "I9", "GD1"))
mod <- lmer(Amplitude_mV ~ Genotype * Condition * Brainregion + (1|Exp_ID), subset(df.ag.peak, Genotype %in% c("WT", "KO")))
summary(mod)
emmeans(mod, trt.vs.ctrl ~ Condition | Genotype | Brainregion, ref="BASE")
emmeans(mod, trt.vs.ctrl ~ Genotype | Condition | Brainregion, ref="WT")

mod <- lmer(log10(isi_s) ~ Genotype * Condition * Brainregion + (1|Exp_ID), subset(df.ag.peak, Genotype %in% c("I9", "GD1")))
summary(mod)
emmeans(mod, trt.vs.ctrl ~ Condition | Genotype | Brainregion, ref="BASE")
emmeans(mod, trt.vs.ctrl ~ Genotype | Condition | Brainregion, ref="I9")

```


## To Save images

Set your plot of interest as a variable and use the function ggsave including location of saving

Example:

```{r}
p2save <- ggplot(df.ag.peak, aes(x=Genotype, y=Amplitude_mV, color=Set, fill=Condition, group=interaction(Genotype, Condition))) + geom_boxplot(alpha=0.4) + geom_point(position=position_jitterdodge(0)) + facet_grid(.~Brainregion, scales="free")


ggsave("C:\\Users\\davec\\Documents\\R-Markdowns\\MEA_James\\MEA\\Amplitudes.png", plot = p2save)

```

ggplots can be customized a lot to your liking. Let me know if you want something specific.

## Session Info

```{r}
sessionInfo()
```




